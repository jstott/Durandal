<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\durandal\js\composition.js - Durandal API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Durandal API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.0.0-pre</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Activator.html">Activator</a></li>
            
                <li><a href="../classes/ActivatorModule.html">ActivatorModule</a></li>
            
                <li><a href="../classes/ActivatorSettings.html">ActivatorSettings</a></li>
            
                <li><a href="../classes/AppModule.html">AppModule</a></li>
            
                <li><a href="../classes/CompositionModule.html">CompositionModule</a></li>
            
                <li><a href="../classes/CompositionTransaction.html">CompositionTransaction</a></li>
            
                <li><a href="../classes/DialogContext.html">DialogContext</a></li>
            
                <li><a href="../classes/DialogModule.html">DialogModule</a></li>
            
                <li><a href="../classes/EntranceModule.html">EntranceModule</a></li>
            
                <li><a href="../classes/Events.html">Events</a></li>
            
                <li><a href="../classes/EventsModule.html">EventsModule</a></li>
            
                <li><a href="../classes/HistoryModule.html">HistoryModule</a></li>
            
                <li><a href="../classes/HistoryOptions.html">HistoryOptions</a></li>
            
                <li><a href="../classes/HTTPModule.html">HTTPModule</a></li>
            
                <li><a href="../classes/MessageBox.html">MessageBox</a></li>
            
                <li><a href="../classes/ObservableModule.html">ObservableModule</a></li>
            
                <li><a href="../classes/Router.html">Router</a></li>
            
                <li><a href="../classes/RouterModule.html">RouterModule</a></li>
            
                <li><a href="../classes/SerializerModule.html">SerializerModule</a></li>
            
                <li><a href="../classes/Subscription.html">Subscription</a></li>
            
                <li><a href="../classes/SystemModule.html">SystemModule</a></li>
            
                <li><a href="../classes/ViewEngineModule.html">ViewEngineModule</a></li>
            
                <li><a href="../classes/ViewLocatorModule.html">ViewLocatorModule</a></li>
            
                <li><a href="../classes/ViewModelBinderModule.html">ViewModelBinderModule</a></li>
            
                <li><a href="../classes/WidgetModule.html">WidgetModule</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/activator.html">activator</a></li>
            
                <li><a href="../modules/app.html">app</a></li>
            
                <li><a href="../modules/composition.html">composition</a></li>
            
                <li><a href="../modules/dialog.html">dialog</a></li>
            
                <li><a href="../modules/entrance.html">entrance</a></li>
            
                <li><a href="../modules/events.html">events</a></li>
            
                <li><a href="../modules/history.html">history</a></li>
            
                <li><a href="../modules/http.html">http</a></li>
            
                <li><a href="../modules/observable.html">observable</a></li>
            
                <li><a href="../modules/router.html">router</a></li>
            
                <li><a href="../modules/serializer.html">serializer</a></li>
            
                <li><a href="../modules/system.html">system</a></li>
            
                <li><a href="../modules/viewEngine.html">viewEngine</a></li>
            
                <li><a href="../modules/viewLocator.html">viewLocator</a></li>
            
                <li><a href="../modules/viewModelBinder.html">viewModelBinder</a></li>
            
                <li><a href="../modules/widget.html">widget</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\durandal\js\composition.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * The composition module encapsulates all functionality related to visual composition.
 * @module composition
 * @requires system
 * @requires viewLocator
 * @requires viewModelBinder
 * @requires viewEngine
 * @requires activator
 * @requires jquery
 * @requires knockout
 */
define([&#x27;durandal/system&#x27;, &#x27;durandal/viewLocator&#x27;, &#x27;durandal/viewModelBinder&#x27;, &#x27;durandal/viewEngine&#x27;, &#x27;durandal/activator&#x27;, &#x27;jquery&#x27;, &#x27;knockout&#x27;], function (system, viewLocator, viewModelBinder, viewEngine, activator, $, ko) {
    var dummyModel = {},
        activeViewAttributeName = &#x27;data-active-view&#x27;,
        composition,
        compositionCompleteCallbacks = [],
        compositionCount = 0,
        compositionDataKey = &#x27;durandal-composition-data&#x27;,
        partAttributeName = &#x27;data-part&#x27;,
        partAttributeSelector = &#x27;[&#x27; + partAttributeName + &#x27;]&#x27;,
        bindableSettings = [&#x27;model&#x27;, &#x27;view&#x27;, &#x27;transition&#x27;, &#x27;area&#x27;, &#x27;strategy&#x27;, &#x27;activationData&#x27;];

    function getHostState(parent) {
        var elements = [];
        var state = {
            childElements: elements,
            activeView: null
        };

        var child = ko.virtualElements.firstChild(parent);

        while (child) {
            if (child.nodeType == 1) {
                elements.push(child);
                if (child.getAttribute(activeViewAttributeName)) {
                    state.activeView = child;
                }
            }

            child = ko.virtualElements.nextSibling(child);
        }

        if(!state.activeView){
            state.activeView = elements[0];
        }

        return state;
    }

    function endComposition() {
        compositionCount--;

        if (compositionCount === 0) {
            setTimeout(function(){
                var i = compositionCompleteCallbacks.length;

                while(i--) {
                    compositionCompleteCallbacks[i]();
                }

                compositionCompleteCallbacks = [];
            }, 1);
        }
    }

    function tryActivate(context, successCallback, skipActivation) {
        if(skipActivation){
            successCallback();
        } else if (context.activate &amp;&amp; context.model &amp;&amp; context.model.activate) {
            var result;

            if(system.isArray(context.activationData)) {
                result = context.model.activate.apply(context.model, context.activationData);
            } else {
                result = context.model.activate(context.activationData);
            }

            if(result &amp;&amp; result.then) {
                result.then(successCallback);
            } else if(result || result === undefined) {
                successCallback();
            } else {
                endComposition();
            }
        } else {
            successCallback();
        }
    }

    function triggerAttach() {
        var context = this;

        if (context.activeView) {
            context.activeView.removeAttribute(activeViewAttributeName);
        }

        if (context.child) {
            if (context.model &amp;&amp; context.model.attached) {
                if (context.composingNewView || context.alwaysTriggerAttach) {
                    context.model.attached(context.child, context.parent, context);
                }
            }

            if (context.attached) {
                context.attached(context.child, context.parent, context);
            }

            context.child.setAttribute(activeViewAttributeName, true);

            if (context.composingNewView &amp;&amp; context.model) {
                if (context.model.compositionComplete) {
                    composition.current.complete(function () {
                        context.model.compositionComplete(context.child, context.parent, context);
                    });
                }

                if (context.model.detached) {
                    ko.utils.domNodeDisposal.addDisposeCallback(context.child, function () {
                        context.model.detached(context.child, context.parent, context);
                    });
                }
            }

            if (context.compositionComplete) {
                composition.current.complete(function () {
                    context.compositionComplete(context.child, context.parent, context);
                });
            }
        }

        endComposition();
        context.triggerAttach = system.noop;
    }

    function shouldTransition(context) {
        if (system.isString(context.transition)) {
            if (context.activeView) {
                if (context.activeView == context.child) {
                    return false;
                }

                if (!context.child) {
                    return true;
                }

                if (context.skipTransitionOnSameViewId) {
                    var currentViewId = context.activeView.getAttribute(&#x27;data-view&#x27;);
                    var newViewId = context.child.getAttribute(&#x27;data-view&#x27;);
                    return currentViewId != newViewId;
                }
            }

            return true;
        }

        return false;
    }

    function cloneNodes(nodesArray) {
        for (var i = 0, j = nodesArray.length, newNodesArray = []; i &lt; j; i++) {
            var clonedNode = nodesArray[i].cloneNode(true);
            newNodesArray.push(clonedNode);
        }
        return newNodesArray;
    }

    function replaceParts(context){
        var parts = cloneNodes(context.parts);
        var replacementParts = composition.getParts(parts);
        var standardParts = composition.getParts(context.child);

        for (var partId in replacementParts) {
            $(standardParts[partId]).replaceWith(replacementParts[partId]);
        }
    }

    function removePreviousView(parent){
        var children = ko.virtualElements.childNodes(parent), i, len;

        if(!system.isArray(children)){
            var arrayChildren = [];

            for(i = 0, len = children.length; i &lt; len; i++){
                arrayChildren[i] = children[i];
            }

            children = arrayChildren;
        }

        for(i = 1,len = children.length; i &lt; len; i++){
            ko.removeNode(children[i]);
        }
    }

    /**
     * @class CompositionTransaction
     * @static
     */
    var compositionTransaction = {
        /**
         * Registers a callback which will be invoked when the current composition transaction has completed. The transaction includes all parent and children compositions.
         * @method complete
         * @param {function} callback The callback to be invoked when composition is complete.
         */
        complete: function (callback) {
            compositionCompleteCallbacks.push(callback);
        }
    };

    /**
     * @class CompositionModule
     * @static
     */
    composition = {
        /**
         * Converts a transition name to its moduleId.
         * @method convertTransitionToModuleId
         * @param {string} name The name of the transtion.
         * @return {string} The moduleId.
         */
        convertTransitionToModuleId: function (name) {
            return &#x27;transitions/&#x27; + name;
        },
        /**
         * Represents the currently executing composition transaction.
         * @property {CompositionTransaction} current
         */
        current: compositionTransaction,
        /**
         * Registers a binding handler that will be invoked when the current composition transaction is complete.
         * @method addBindingHandler
         * @param {string} name The name of the binding handler.
         * @param {object} [config] The binding handler instance. If none is provided, the name will be used to look up an existing handler which will then be converted to a composition handler.
         * @param {function} [initOptionsFactory] If the registered binding needs to return options from its init call back to knockout, this function will server as a factory for those options. It will receive the same parameters that the init function does.
         */
        addBindingHandler:function(name, config, initOptionsFactory){
            var key,
                dataKey = &#x27;composition-handler-&#x27; + name,
                handler;

            config = config || ko.bindingHandlers[name];
            initOptionsFactory = initOptionsFactory || function(){ return undefined;  };

            handler = ko.bindingHandlers[name] = {
                init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                    var data = {
                        trigger:ko.observable(null)
                    };

                    composition.current.complete(function(){
                        if(config.init){
                            config.init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
                        }

                        if(config.update){
                            ko.utils.domData.set(element, dataKey, config);
                            data.trigger(&#x27;trigger&#x27;);
                        }
                    });

                    ko.utils.domData.set(element, dataKey, data);

                    return initOptionsFactory(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
                },
                update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                    var data = ko.utils.domData.get(element, dataKey);

                    if(data.update){
                        return data.update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
                    }

                    data.trigger();
                }
            };

            for (key in config) {
                if (key !== &quot;init&quot; &amp;&amp; key !== &quot;update&quot;) {
                    handler[key] = config[key];
                }
            }
        },
        /**
         * Gets an object keyed with all the elements that are replacable parts, found within the supplied elements. The key will be the part name and the value will be the element itself.
         * @method getParts
         * @param {DOMElement\DOMElement[]} elements The element(s) to search for parts.
         * @return {object} An object keyed by part.
         */
        getParts: function(elements) {
            var parts = {};

            if (!system.isArray(elements)) {
                elements = [elements];
            }

            for (var i = 0; i &lt; elements.length; i++) {
                var element = elements[i];

                if (element.getAttribute) {
                    var id = element.getAttribute(partAttributeName);
                    if (id) {
                        parts[id] = element;
                    }

                    var childParts = $(partAttributeSelector, element)
                        .not($(&#x27;[data-bind] &#x27; + partAttributeSelector, element));

                    for (var j = 0; j &lt; childParts.length; j++) {
                        var part = childParts.get(j);
                        parts[part.getAttribute(partAttributeName)] = part;
                    }
                }
            }

            return parts;
        },
        cloneNodes:cloneNodes,
        finalize: function (context) {
            context.transition = context.transition || this.defaultTransitionName;

            if(!context.child &amp;&amp; !context.activeView){
                if (!context.cacheViews) {
                    ko.virtualElements.emptyNode(context.parent);
                }

                context.triggerAttach();
            }else if (shouldTransition(context)) {
                var transitionModuleId = this.convertTransitionToModuleId(context.transition);

                system.acquire(transitionModuleId).then(function (transition) {
                    context.transition = transition;

                    transition(context).then(function () {
                        if (!context.cacheViews) {
                            if(!context.child){
                                ko.virtualElements.emptyNode(context.parent);
                            }else{
                                removePreviousView(context.parent);
                            }
                        }else if(context.activeView){
                            var instruction = viewModelBinder.getBindingInstruction(context.activeView);
                            if(instruction.cacheViews != undefined &amp;&amp; !instruction.cacheViews){
                                ko.removeNode(context.activeView);
                            }
                        }

                        context.triggerAttach();
                    });
                });
            } else {
                if (context.child != context.activeView) {
                    if (context.cacheViews &amp;&amp; context.activeView) {
                        var instruction = viewModelBinder.getBindingInstruction(context.activeView);
                        if(instruction.cacheViews != undefined &amp;&amp; !instruction.cacheViews){
                            ko.removeNode(context.activeView);
                        }else{
                            $(context.activeView).hide();
                        }
                    }

                    if (!context.child) {
                        if (!context.cacheViews) {
                            ko.virtualElements.emptyNode(context.parent);
                        }
                    } else {
                        if (!context.cacheViews) {
                            removePreviousView(context.parent);
                        }

                        $(context.child).show();
                    }
                }

                context.triggerAttach();
            }
        },
        bindAndShow: function (child, context, skipActivation) {
            context.child = child;

            if (context.cacheViews) {
                context.composingNewView = (ko.utils.arrayIndexOf(context.viewElements, child) == -1);
            } else {
                context.composingNewView = true;
            }

            tryActivate(context, function () {
                if (context.beforeBind) {
                    context.beforeBind(child, context);
                }

                if (context.preserveContext &amp;&amp; context.bindingContext) {
                    if (context.composingNewView) {
                        if(context.parts){
                            replaceParts(context);
                        }

                        $(child).hide();
                        ko.virtualElements.prepend(context.parent, child);

                        viewModelBinder.bindContext(context.bindingContext, child, context.model);
                    }
                } else if (child) {
                    var modelToBind = context.model || dummyModel;
                    var currentModel = ko.dataFor(child);

                    if (currentModel != modelToBind) {
                        if (!context.composingNewView) {
                            $(child).remove();
                            viewEngine.createView(child.getAttribute(&#x27;data-view&#x27;)).then(function(recreatedView) {
                                composition.bindAndShow(recreatedView, context, true);
                            });
                            return;
                        }

                        if(context.parts){
                            replaceParts(context);
                        }

                        $(child).hide();
                        ko.virtualElements.prepend(context.parent, child);

                        viewModelBinder.bind(modelToBind, child);
                    }
                }

                composition.finalize(context);
            }, skipActivation);
        },
        /**
         * Eecutes the default view location strategy.
         * @method defaultStrategy
         * @param {object} context The composition context containing the model and possibly existing viewElements.
         * @return {promise} A promise for the view.
         */
        defaultStrategy: function (context) {
            return viewLocator.locateViewForObject(context.model, context.viewElements);
        },
        getSettings: function (valueAccessor, element) {
            var value = valueAccessor(),
                settings = ko.utils.unwrapObservable(value) || {},
                activatorPresent = activator.isActivator(value),
                moduleId;

            if (system.isString(settings)) {
                if (viewEngine.isViewUrl(settings)) {
                    settings = {
                        view: settings
                    };
                } else {
                    settings = {
                        model: settings,
                        activate: true
                    };
                }

                return settings;
            }

            moduleId = system.getModuleId(settings);
            if (moduleId) {
                settings = {
                    model: settings,
                    activate: true
                };

                return settings;
            }

            if(!activatorPresent &amp;&amp; settings.model) {
                activatorPresent = activator.isActivator(settings.model);
            }

            for (var attrName in settings) {
                if (ko.utils.arrayIndexOf(bindableSettings, attrName) != -1) {
                    settings[attrName] = ko.utils.unwrapObservable(settings[attrName]);
                } else {
                    settings[attrName] = settings[attrName];
                }
            }

            if (activatorPresent) {
                settings.activate = false;
            } else if (settings.activate === undefined) {
                settings.activate = true;
            }

            return settings;
        },
        executeStrategy: function (context) {
            context.strategy(context).then(function (child) {
                composition.bindAndShow(child, context);
            });
        },
        inject: function (context) {
            if (!context.model) {
                this.bindAndShow(null, context);
                return;
            }

            if (context.view) {
                viewLocator.locateView(context.view, context.area, context.viewElements).then(function (child) {
                    composition.bindAndShow(child, context);
                });
                return;
            }

            if (!context.strategy) {
                context.strategy = this.defaultStrategy;
            }

            if (system.isString(context.strategy)) {
                system.acquire(context.strategy).then(function (strategy) {
                    context.strategy = strategy;
                    composition.executeStrategy(context);
                });
            } else {
                this.executeStrategy(context);
            }
        },
        /**
         * Initiates a composition.
         * @method compose
         * @param {DOMElement} element The DOMElement or knockout virtual element that serves as the parent for the composition.
         * @param {object} settings The composition settings.
         * @param {object} [bindingContext] The current binding context.
         */
        compose: function (element, settings, bindingContext, fromBinding) {
            compositionCount++;

            if(!fromBinding){
                settings = composition.getSettings(function() { return settings; }, element);
            }

            var hostState = getHostState(element);

            settings.activeView = hostState.activeView;
            settings.parent = element;
            settings.triggerAttach = triggerAttach;
            settings.bindingContext = bindingContext;

            if (settings.cacheViews &amp;&amp; !settings.viewElements) {
                settings.viewElements = hostState.childElements;
            }

            if (!settings.model) {
                if (!settings.view) {
                    this.bindAndShow(null, settings);
                } else {
                    settings.area = settings.area || &#x27;partial&#x27;;
                    settings.preserveContext = true;

                    viewLocator.locateView(settings.view, settings.area, settings.viewElements).then(function (child) {
                        composition.bindAndShow(child, settings);
                    });
                }
            } else if (system.isString(settings.model)) {
                system.acquire(settings.model).then(function (module) {
                    settings.model = system.resolveObject(module);
                    composition.inject(settings);
                });
            } else {
                composition.inject(settings);
            }
        }
    };

    ko.bindingHandlers.compose = {
        init: function() {
            return { controlsDescendantBindings: true };
        },
        update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var settings = composition.getSettings(valueAccessor, element);
            if(settings.mode){
                var data = ko.utils.domData.get(element, compositionDataKey);
                if(!data){
                    var childNodes = ko.virtualElements.childNodes(element);
                    data = {};

                    if(settings.mode === &#x27;inline&#x27;){
                        data.view = viewEngine.ensureSingleElement(childNodes);
                    }else if(settings.mode === &#x27;templated&#x27;){
                        data.parts = cloneNodes(childNodes);
                    }

                    ko.virtualElements.emptyNode(element);
                    ko.utils.domData.set(element, compositionDataKey, data);
                }

                if(settings.mode === &#x27;inline&#x27;){
                    settings.view = data.view.cloneNode(true);
                }else if(settings.mode === &#x27;templated&#x27;){
                    settings.parts = data.parts;
                }

                settings.preserveContext = true;
            }

            composition.compose(element, settings, bindingContext, true);
        }
    };

    ko.virtualElements.allowedBindings.compose = true;

    return composition;
});
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
